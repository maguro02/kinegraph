
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async getSystemInfo() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_system_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * ユーザー入力を処理し、描画コマンドを返す
 */
async processUserInput(input: UserInput) : Promise<Result<DrawCommand[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("process_user_input", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 現在の描画状態を取得
 */
async getDrawingState() : Promise<Result<DrawingStateInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_drawing_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async initializeDrawingEngine() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("initialize_drawing_engine") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createDrawingLayer(layerId: string, width: number, height: number) : Promise<Result<CreateLayerResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_drawing_layer", { layerId, width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeLayer(layerId: string) : Promise<Result<RemoveLayerResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_layer", { layerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async initCanvas(width: number, height: number) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_canvas", { width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async drawCommand(command: DrawEngineCommand) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("draw_command", { command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRenderResult(canvasId: string) : Promise<Result<RenderResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_render_result", { canvasId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resizeCanvas(canvasId: string, width: number, height: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resize_canvas", { canvasId, width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCompressedRenderResult(canvasId: string) : Promise<Result<RenderResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_compressed_render_result", { canvasId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDiffRenderResult(canvasId: string) : Promise<Result<DiffRenderResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_diff_render_result", { canvasId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearRenderCache(canvasId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_render_cache", { canvasId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type BinaryTransfer = { format: ImageFormat; width: number; height: number; compressed: boolean; data: number[] }
export type BlendMode = "normal" | "multiply" | "screen" | "overlay"
export type BrushSettings = { size: number; opacity: number; color: [number, number, number, number]; brushType: BrushType; blendMode: BlendMode }
export type BrushType = "pen" | "brush" | "eraser"
/**
 * レイヤー作成のレスポンス
 */
export type CreateLayerResponse = { status: string; layer_id: string; commands: DrawCommand[] }
export type DiffRenderResult = { canvasId: string; dirtyRegion: DirtyRegionData | null; timestamp: number }
export type DirtyRegionData = { x: number; y: number; width: number; height: number; imageData: BinaryTransfer }
export type DrawEngineCommand = { beginStroke: { x: number; y: number; pressure: number } } | { continueStroke: { x: number; y: number; pressure: number } } | "endStroke" | "clear" | { setBrush: BrushSettings } | { setActiveLayer: number } | "createLayer" | { deleteLayer: number }
/**
 * 描画コマンド（フロントエンドへの描画指示）
 */
export type DrawCommand = 
/**
 * キャンバス全体をクリア
 */
{ type: "ClearCanvas" } | 
/**
 * パスを描画
 */
{ type: "DrawPath"; payload: { points: Point[]; color: string; width: number; layer_id: string } } | 
/**
 * 矩形領域を更新（部分的なラスターデータ更新用）
 */
{ type: "UpdateRasterArea"; payload: { rect: Rect; pixel_data: number[]; layer_id: string } } | 
/**
 * レイヤーを追加
 */
{ type: "AddLayer"; payload: { layer_id: string; index: number } } | 
/**
 * レイヤーを削除
 */
{ type: "RemoveLayer"; payload: { layer_id: string } } | 
/**
 * レイヤーの順序を変更
 */
{ type: "ReorderLayers"; payload: { layer_ids: string[] } } | 
/**
 * レイヤーのプロパティを更新
 */
{ type: "UpdateLayerProperties"; payload: { layer_id: string; opacity: number; blend_mode: string; visible: boolean } } | 
/**
 * 選択範囲を表示
 */
{ type: "ShowSelection"; payload: { selection_type: SelectionType; points: Point[] } } | 
/**
 * 選択範囲をクリア
 */
{ type: "ClearSelection" } | 
/**
 * 変形マトリックスを適用
 */
{ type: "ApplyTransform"; payload: { layer_id: string; transform: Transform } } | 
/**
 * 複数のコマンドをバッチ実行
 */
{ type: "Batch"; payload: { commands: DrawCommand[] } }
export type DrawingStateInfo = { layers: HybridLayerInfo[]; active_layer_id: string | null; current_tool: string; current_color: string; current_brush_size: number }
export type HybridLayerInfo = { id: string; name: string; visible: boolean; opacity: number; blend_mode: string }
export type ImageFormat = "rgba8" | "rgb8"
/**
 * 2D座標
 */
export type Point = { x: number; y: number }
/**
 * 矩形領域
 */
export type Rect = { x: number; y: number; width: number; height: number }
/**
 * レイヤー削除のレスポンス
 */
export type RemoveLayerResponse = { status: string; removed_layer_id: string; commands: DrawCommand[] }
export type RenderResult = { canvasId: string; imageData: BinaryTransfer; timestamp: number }
/**
 * 選択範囲のタイプ
 */
export type SelectionType = "rectangle" | "lasso" | "magic"
/**
 * 変形情報
 */
export type Transform = { translate_x: number; translate_y: number; scale_x: number; scale_y: number; rotation: number }
/**
 * ユーザー操作を表す入力コマンド
 */
export type UserInput = 
/**
 * ストロークを描画
 */
{ type: "DrawStroke"; payload: { points: Point[]; color: string; width: number; layer_id: string } } | 
/**
 * 現在のツールを変更
 */
{ type: "ChangeTool"; payload: { tool_id: string } } | 
/**
 * レイヤーを作成
 */
{ type: "CreateLayer"; payload: { name: string } } | 
/**
 * レイヤーを削除
 */
{ type: "DeleteLayer"; payload: { layer_id: string } } | 
/**
 * レイヤーの順序を変更
 */
{ type: "ReorderLayer"; payload: { layer_id: string; new_index: number } } | 
/**
 * レイヤーの不透明度を変更
 */
{ type: "ChangeLayerOpacity"; payload: { layer_id: string; opacity: number } } | 
/**
 * レイヤーのブレンドモードを変更
 */
{ type: "ChangeLayerBlendMode"; payload: { layer_id: string; blend_mode: string } } | 
/**
 * 塗りつぶし
 */
{ type: "Fill"; payload: { point: Point; color: string; layer_id: string } } | 
/**
 * 選択範囲を作成
 */
{ type: "CreateSelection"; payload: { selection_type: SelectionType; points: Point[] } } | 
/**
 * 選択範囲を変形
 */
{ type: "TransformSelection"; payload: { transform: Transform } } | 
/**
 * Undo操作
 */
{ type: "Undo" } | 
/**
 * Redo操作
 */
{ type: "Redo" }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

// @ts-ignore
function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
